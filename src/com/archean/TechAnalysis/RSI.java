/*
 * jCryptoTrader trading client
 * Copyright (C) 2014 1M4SKfh83ZxsCSDmfaXvfCfMonFxMa5vvh (BTC public key)
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 */

// Developed J. Welles Wilder, the Relative Strength Index (RSI) is a momentum oscillator that measures the speed and change of price movements. RSI oscillates between zero and 100. Traditionally, and according to Wilder, RSI is considered overbought when above 70 and oversold when below 30. Signals can also be generated by looking for divergences, failure swings and centerline crossovers. RSI can also be used to identify the general trend.

package com.archean.TechAnalysis;

import com.archean.jtradeapi.HistoryUtils;
import lombok.NonNull;

import java.math.BigDecimal;
import java.math.MathContext;
import java.math.RoundingMode;
import java.util.ArrayList;
import java.util.List;

public class RSI {
    private static List<TAUtils.PriceChange> makeUDChangesList(@NonNull List<TAUtils.PriceChange> changes, boolean positive) {
        List<TAUtils.PriceChange> result = new ArrayList<>();
        for (TAUtils.PriceChange priceChange : changes) {
            if (positive == priceChange.isPositive()) {
                result.add(priceChange);
            }
        }
        return result;
    }

    private static BigDecimal relativeStrength(BigDecimal u, BigDecimal d) {
        return u.divide(d, TAUtils.ROUNDING_PRECISION, TAUtils.ROUNDING_MODE);
    }
    private final static BigDecimal BIG_DECIMAL_ONE_HUNDRED = new BigDecimal(100.0, MathContext.DECIMAL64);
    private static BigDecimal relativeStrengthIndex(BigDecimal relativeStrength) {
        return BIG_DECIMAL_ONE_HUNDRED.subtract(BIG_DECIMAL_ONE_HUNDRED.divide(relativeStrength.add(BigDecimal.ONE), TAUtils.ROUNDING_PRECISION, TAUtils.ROUNDING_MODE));
    }

    private static final BigDecimal emaAlpha = new BigDecimal(0.9, MathContext.DECIMAL64);
    public static List<HistoryUtils.TimestampedChartData> build(@NonNull List<TAUtils.PriceChange> changes, int period) {
        List<HistoryUtils.TimestampedChartData> result = new ArrayList<>();
        MovingAverage.Parameters maParams = new MovingAverage.Parameters(MovingAverage.MovingAverageType.EMA, period, emaAlpha);
        MovingAverage.MovingAverageBuilder positiveEma = new MovingAverage.MovingAverageBuilder(maParams), negativeEma = new MovingAverage.MovingAverageBuilder(maParams);

        BigDecimal uValue, dValue;
        for (TAUtils.PriceChange change : changes) {
            if(change.isPositive()) {
                positiveEma.put(change.getSecondDate(), change.getSecondPrice());
            } else {
                negativeEma.put(change.getSecondDate(), change.getSecondPrice());
            }
            HistoryUtils.TimestampedChartData uLast = positiveEma.getLast(), dLast = negativeEma.getLast();
            uValue = uLast != null && uLast.value.compareTo(BigDecimal.ZERO) != 0 ? uLast.value : BIG_DECIMAL_ONE_HUNDRED;
            dValue = dLast != null && dLast.value.compareTo(BigDecimal.ZERO) != 0 ? dLast.value : BIG_DECIMAL_ONE_HUNDRED;
            BigDecimal RS = relativeStrength(uValue, dValue);
            result.add(new HistoryUtils.TimestampedChartData(change.getSecondDate(), relativeStrengthIndex(RS)));
        }
        return result;
    }
}
