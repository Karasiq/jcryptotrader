/*
 * jCryptoTrader trading client
 * Copyright (C) 2014 1M4SKfh83ZxsCSDmfaXvfCfMonFxMa5vvh (BTC public key)
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 */

// Developed J. Welles Wilder, the Relative Strength Index (RSI) is a momentum oscillator that measures the speed and change of price movements. RSI oscillates between zero and 100. Traditionally, and according to Wilder, RSI is considered overbought when above 70 and oversold when below 30. Signals can also be generated by looking for divergences, failure swings and centerline crossovers. RSI can also be used to identify the general trend.

package com.archean.TechAnalysis;

import com.archean.jtradeapi.HistoryUtils;

import java.math.BigDecimal;
import java.math.MathContext;
import java.util.ArrayList;
import java.util.List;

public class RSI {
    private static List<TAUtils.PriceChange> makeUDChangesList(List<TAUtils.PriceChange> changes, boolean positive) {
        List<TAUtils.PriceChange> result = new ArrayList<>();
        for(TAUtils.PriceChange priceChange : changes) if(positive == priceChange.isPositive()) {
            result.add(priceChange);
        } else {
            result.add(new TAUtils.PriceChange(priceChange.getFirstPrice(), priceChange.getFirstPrice())); // absolute = 0
        }
        return result;
    }
    private static BigDecimal relativeStrength(BigDecimal u, BigDecimal d) {
        return u.divide(d);
    }
    private static BigDecimal relativeStrengthIndex(BigDecimal relativeStrength) {
        final BigDecimal BIG_DECIMAL_ONE_HUNDRED = new BigDecimal(100);
        return BIG_DECIMAL_ONE_HUNDRED.subtract(BIG_DECIMAL_ONE_HUNDRED.divide(BigDecimal.ONE.add(relativeStrength)));
    }

    public static List<BigDecimal> build(List<TAUtils.PriceChange> changes) {
        List<BigDecimal> result = new ArrayList<>();
        List<TAUtils.PriceChange> positive = makeUDChangesList(changes, true), negative = makeUDChangesList(changes, false);
        MovingAverage movingAverage = new MovingAverage();
        movingAverage.setType(MovingAverage.MovingAverageType.EMA);
        List<BigDecimal> positiveEma = movingAverage.build(positive), negativeEma = movingAverage.build(negative);
        for(int i = 0; i < changes.size(); i++) {
            BigDecimal RS = relativeStrength(positiveEma.get(i), negativeEma.get(i));
            result.add(relativeStrengthIndex(RS));
        }
        return result;
    }
}
